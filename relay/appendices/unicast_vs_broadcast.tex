% !TEX root = zeth_relay

\chapter{Network structure}\label{chap:unicast-vs-broadcast}

\section{Binding requests to relays}

\subsection{Background}

The protocols presented in this document require users to create relay requests that can only be successfully processed by a specific relay. This serves as a mechanism to prevent other network participants from ``stealing'' the relay requests or front-running relay transactions. The alternative to this would be to support ``free'' relay requests, not bound to specific relays, which could therefore be processed by any participant. If these ``free'' requests are made available (or ``broadcast'') to multiple relays, those relays must then ``race'' to process the request and broadcast a corresponding relay transaction. When the first relay transaction is accepted by the blockchain, the ``winning'' relay will receive the relay fee and later transactions from other relays will be rendered invalid (as a consequence of the nullifiers declared in the $\zeth$ relay request being marked as used).

While such an approach is entirely feasible, it increases the risk for relays, making it much harder for them to hedge against lost fees and wasted compute resources. As a consequence, it becomes much more difficult for relays to assess the risk associated with a given request, which in turn is likely to result in an increase in relay fees. All resources used by ``losers'' of the race are wasted.  In contrast, in the case where requests are bound to specific relays, these resources can be used to process multiple requests in parallel, increasing the efficiency of the system.

\subsection{Emulating ``free'' relay requests}\label{unicast-vs-broadcast:requests:emulate-free-requests}

Despite the mechanisms to prevent front-running, the protocols presented in this document could be leveraged by some user (say $\userP$) to force relays to ``compete'' for relay requests.
Specifically, in order to call the \zeth~mixer \mixer~with parameters $\mixparams$, $\userP$ can run multiple instances of a protocol in parallel, generating $N$ relay requests for $\mixparams$, each targeting a different relay. If the user then sends each of these $N$ requests to the targeted relay, the desired state transition will be carried out by the first relay transaction to be accepted into the blockchain, rendering the remaining $N-1$ requests invalid (by the nullifier mechanism cited previously).

As in the case of ``free'' requests, relays are exposed to extra risk for the reasons given above. However, this ``emulating'' approach does provide partial mitigation of this risk, due to the extra cost that the user $\userP$ must incur. Under the protocols given in this document, in order to create $N$ requests targeting different relays, the user must generate $N$ zk-SNARKs, which is computationally demanding and therefore represents a cost to the user. Therefore, request generation may act as a user-side proof-of-work, preventing malicious messages from flooding the network (as originally designed for by Dwork et al.~\cite{DBLP:conf/crypto/DworkN92,Jakobsson1999ProofsOW}). This naturally leads to the following process by which relays can partially protect against some DoS vectors, by performing the following checks on relay requests:
\begin{enumerate}
    \item Verify that none of the nullifiers in the request has been seen in previously received requests (inspect the mempool and the blockchain state). If one or more nullifiers is a duplicate then reject the request, else proceed.
    \item Verify the zk-SNARK proof in the request. If the proof is invalid, reject the request. Otherwise the request can be considered for processing.
\end{enumerate}

In this way, the cost of generating $N$ proofs imposes some upper bound on the message output rate of a potential attacker.

\section{Unicast vs broadcast networks}\label{unicast-vs-broadcast:unicast-vs-broadcast}

The discussions in this document assume only that some transport mechanism exists for users to send relay requests to specific relays. As noted in \cref{preliminaries:introduction}, users can achieve further anonymity if this transport mechanism does not require the user to reveal any identifying information at the network level. We now discuss some specific implementations of the transport layer (namely ``unicast'' vs ``broadcast'' networks), and their respective properties.

By design, relay requests are bound to specific relays, which intuitively implies a ``unicast'' style transport mechanism. That is, relays publish a network address of some form, and users send requests to this address. Observers of the physical network may determine that a message has been sent from the user to the relay, but the content of the message (i.e.~the details of the relay request) is not visible to other participants. This is a natural choice given that relay request data cannot be used by parties other than the targeted relay. While not a requirement of any of these protocols, unicast channels (in particular point-to-point communication channels, which we assume to be encrypted by default) only reveal the relay request content to the relay itself. Adversaries able to gain control a physical network node along the route between user and relay (in general a limited set of nodes, which varies depending on user and relay) may learn that a message was sent from the user to the relay, but they will not learn anything about the message content. Such communication channels also allow for interaction between relay and user (for example, the relay could dynamically select an \ethereum~or \zeth~address to receive payment, or privately negotiate fees with the user).

Clearly it would be entirely possible to implement these protocols using a ``broadcast'' system, such as those employed by blockchains to propagate transactions and blocks. Requests could be broadcast unencrypted without impacting the reliability of the system, as long as messages were eventually seen by the target relay. Broadcast networks provide some inherent receiver anonymity, in the sense that it is more difficult to identify which \emph{network node} is the recipient of a given message, however in this setting, all participants in the system would be able to see the content of relay requests and potentially determine the number of requests received by each relay identity (and, in turn, infer information about their profit). Despite relay requests being visible to other participants, the protocol would still prevent other relays from profiting from these requests, since they are bound to the target relay. Further, the content of requests could be hidden by encryption so that only the intended relay may read them. Instead of publishing a network ``address'' of some form, relays could publish an encryption key, with which users must encrypt requests before broadcasting them (although care must be taken to use a key-private encryption scheme to avoid leaking information about the recipient).

While broadcast networks could theoretically be used in these relay protocols, unicast networks are more bandwidth efficient (i.e.~a given message needs only to find a path through the network in order to flow from the sender to the recipient). In contrast, broadcast networks may provide a level of sender anonymity in the face of network observers, although even in broadcast networks methods exist to infer the message originator (e.g.~nodes with high degree\footnote{In the graph theoretical sense.} -- also referred to as ``supernodes'' -- can be used to infer the sender of a message on a broadcast channel by using timing information~\cite{DBLP:conf/fc/KoshyKM14}). Broadcast communication channels are also of great interest to achieve ``recipient anonymity''(see~\cite{DBLP:journals/compsec/PfitzmannW87} for more details on ``anonymity'').

At first sight, the use of a unicast transport may appear to increase the centralization of the system. However, this is demonstrably not the case for the protocols discussed here, which can (as described above) be implemented using a transparent broadcast network and do not inherently rely on any centralization.

Finally, we note that, although broadcast networks could theoretically be used, we suggest that unicast networks are likely to be more suitable, given their lower bandwidth and complexity.

\section{Network anonymity}\label{unicast-vs-broadcast:network-anonymity}

Relay protocol designers may choose to transmit requests via the method that best fits their needs, taking into consideration the tradeoffs mentioned in \cref{unicast-vs-broadcast:unicast-vs-broadcast} above. As well as overhead, network topology also has a strong influence on anonymity~\cite{DBLP:conf/pet/DiazMT10}). However, in order to achieve strong privacy guarantees, anonymisation techniques (e.g.~cover traffic, message padding etc.) must be used, to minimize communication leakages.

While protocols like Dandelion~\cite{DBLP:journals/pomacs/Venkatakrishnan17,DBLP:journals/pomacs/FantiVBDBMV18} were initially introduced to improve \emph{diffusion} mechanisms and improve network anonymity on Bitcoin, they could also be of interest in the context of relay request broadcasts (as alluded to in~\cref{unicast-vs-broadcast:unicast-vs-broadcast}).
However, other techniques (providing different properties) may also be of interest for relay network. Some of these are given below:
\begin{itemize}
    \item DC-nets~\cite{DBLP:journals/joc/Chaum88} provide strong guarantees with respect to the sender anonymity (but generally incur a big overhead and require large amounts of randomness).
    \item Crowds~\cite{DBLP:journals/tissec/ReiterR98} follow a ``blending into a crowd'' approach (i.e.~hiding one's actions among the actions of many others), in which a user's request is randomly circulated in a ``crowd'' (set of users) before being submitted -- by a random member of the crowd -- and sent to the destination\footnote{Crowd members \emph{cannot} identify the initiator of the request. The initiator is indistinguishable from a member that forwards a request from another user.}. Note that such approaches generally do not provide strong guarantees with respect to recipient anonymity\footnote{While relay anonymity is not our principal focus, it is worth keeping in mind the impact of side channel leakages which can be used to infer information about the sender. For instance, a powerful adversary -- monitoring a big part of the Internet -- may notice a client access the relay's public information (such as the relay's website) followed by a message to the relay from a crowd to which the client belongs. The adversary may then infer that the client was the relay user. Hence, additional care needs to be allocated to the relay discovery mechanism itself, and the right trade-offs must be made depending on the application and associated threat model.}.
    \item Mix networks (or \emph{mixnets})~\cite{DBLP:series/ais/Chaum03}, in which nodes (``mix nodes'') are routers that perform cryptographic operations (providing bit-wise unlinkability), and modify the order in which output messages are emitted. This hides any correspondence between input and output messages.
    \item Onion routing~\cite{DBLP:journals/cacm/GoldschlagRS99} (which also underlies ``garlic routing''~\cite{garlic-nets}) consists of multiple layers of encryption (one per ``hop'' on the network). Requests are sent through a chosen set of routers (forming a ``circuit'') in order to obfuscate the link between sender and recipient, as seen by non-global adversaries (i.e.~those that do not control all nodes on the circuit\footnote{In some cases, controlling the ``entry'' and ``exit'' nodes (i.e.~first and last nodes of the chain/circuit) is sufficient to carry out so-called ``correlation attacks''. See~\url{https://github.com/Attacks-on-Tor/Attacks-on-Tor} for a list of attacks on Tor~\cite{DBLP:conf/uss/DingledineMS04}}). This generally achieves low-latency relative to other approaches.
\end{itemize}

Importantly, modern protocols building on these techniques use additional mechanisms for enhanced robustness (e.g.~``cover traffic'' to prevent timing attacks etc.).

\begin{remark}
    We note that accountable anonymous communication networks~\cite{DBLP:books/sp/07/DiazP07} are also of great interest in the context of transaction relay protocols as a way to further prevent DoS attacks.
\end{remark}
